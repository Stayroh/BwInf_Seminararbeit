\documentclass[12pt,a4paper]{article}

% ============================================
% PAKETE
% ============================================
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{array}

% ============================================
% SEITENFORMAT (gemäß Vorgabe)
% ============================================
% Seitenränder: li/re 2,5cm, oben/unten 1cm
\geometry{left=2.5cm, right=2.5cm, top=1cm, bottom=1cm, headheight=15pt, includeheadfoot}

% Schriftart: Computer Modern (Standard LaTeX, ähnlich Times New Roman)
% Falls Times New Roman gewünscht: \usepackage{mathptmx}

% Zeilenabstand 1,5-fach
\onehalfspacing

% Kopf- und Fußzeile
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\nouppercase{\leftmark}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

% ============================================
% CODE-STYLING (Courier New ähnlich)
% ============================================
\definecolor{codegreen}{rgb}{0,0.5,0}
\definecolor{codegray}{rgb}{0.4,0.4,0.4}
\definecolor{codepurple}{rgb}{0.5,0,0.5}
\definecolor{codeblue}{rgb}{0,0,0.7}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen}\itshape,
    keywordstyle=\color{codeblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    numbers=left,
    numbersep=8pt,
    frame=single,
    framerule=0.5pt,
    rulecolor=\color{codegray},
    xleftmargin=12pt,
    framexleftmargin=12pt,
    tabsize=4,
    showstringspaces=false,
    captionpos=b,
    literate={ä}{{\"a}}1 {ö}{{\"o}}1 {ü}{{\"u}}1 {Ä}{{\"A}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1 {ß}{{\ss}}1
}
\lstset{style=mystyle}

% ============================================
% HYPERREF EINSTELLUNGEN
% ============================================
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    citecolor=black
}

\begin{document}

% ============================================
% DECKBLATT
% ============================================
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    {\large Stadtteilschule Walddörfer}\\[0.3cm]
    {\large Fach: Seminar}\\[0.3cm]
    {\large Tutor: Frau Dr. Schmidt}\\[2cm]
    
    {\Huge\bfseries Bibertomograph}\\[0.8cm]
    {\Large 44. Bundeswettbewerb Informatik 2025/26 -- 1. Runde}\\[0.3cm]
    {\Large Aufgabe 4}\\[1.5cm]
    
    {\large\itshape Leitfrage: Wie können aus Sichtlinien-Summen die ursprünglichen Figuren rekonstruiert werden?}\\[1.5cm]
    
    \vfill
    
    {\large
    \begin{tabular}{ll}
        Abgabedatum: & 8.12.2025 \\[0.3cm]
        Name: & Jakob Allweiss \\[0.3cm]
        Profil: & Zukunftstechnologien \\
    \end{tabular}
    }
    
    \vspace{2cm}
\end{titlepage}

% ============================================
% INHALTSVERZEICHNIS
% ============================================
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage
\setcounter{page}{1}

% ============================================
% 1. AUFGABE BIBERTOMOGRAPH
% ============================================
\section{Aufgabe Bibertomograph}

Diese Ausarbeitung beschäftigt sich mit der Aufgabe \glqq Bibertomograph\grqq{} aus dem 44. Bundeswettbewerb Informatik (2025/26) und entstand im Rahmen des Seminars im Zeitraum vom 6.10.2025 bis zum 8.12.2025.

\subsection{Fragestellung}

Die originale Aufgabenstellung des Wettbewerbs lautet:

\begin{quote}
\glqq Bei den jährlichen Biberland-Games werden in einer Disziplin aus der Luft sichtbare Figuren auf einer gerasterten Fläche gestaltet. Ein Rasterfeld kann dabei entweder mit Holzspänen gefüllt sein oder nicht. Die Fläche wird vor der Jurywertung den Blicken der neugierigen Biberazzi durch einen Bretterzaun entzogen. Biberazzo Azze hat nun festgestellt, dass er durch kleine Lücken im Zaun senkrecht und diagonal über die Fläche schauen kann und aufgrund der Helligkeit erahnt, wie viele gefüllte Felder auf seiner jeweiligen Sichtlinie liegen. Azze will unbedingt möglichst viele Figuren bereits vorher herausfinden und versucht, durch logische Schlussfolgerungen und Ausprobieren die korrekten Figuren zu rekonstruieren. [...] Hilf Azze mit einem Programm, das für eine beliebige $n \times n$-Fläche die Summen einliest und daraufhin eine dazu passende Figur ausgibt. Falls sie nicht die einzig mögliche ist, sollte das Programm in der Figur die nicht eindeutigen Felder durch Fragezeichen kennzeichnen.\grqq{} [1]
\end{quote}

Bei der Aufgabe geht es also um die Rekonstruktion einer Figur aus ihren Randsummen -- wie viele gefüllte Felder auf jeder horizontalen, vertikalen und diagonalen Sichtlinie liegen.

Gegeben ist ein $n \times n$ Raster, wobei jede Zelle entweder gefüllt (\texttt{\#}) oder leer (\texttt{.}) sein kann. Vom ursprünglichen Bild sind nur die Summen bekannt:

\begin{itemize}
    \item Die \textbf{Spaltensummen}: Wie viele Zellen pro Spalte gefüllt sind
    \item Die \textbf{Zeilensummen}: Wie viele Zellen pro Zeile gefüllt sind
    \item Die \textbf{Hauptdiagonalsummen} (von links-oben nach rechts-unten): Summen entlang der $\searrow$-Diagonalen
    \item Die \textbf{Nebendiagonalsummen} (von links-unten nach rechts-oben): Summen entlang der $\nearrow$-Diagonalen
\end{itemize}

Die Aufgabe besteht darin, aus diesen Informationen das ursprüngliche Bild zu rekonstruieren. Dabei soll das Programm erkennen, ob es genau eine Lösung, mehrere Lösungen oder keine Lösung gibt.

\subsection{Lösungsidee}

Mein erster Gedanke war, das Problem als eine Art Sudoku zu betrachten. Wie beim Sudoku hat man Einschränkungen (Constraints), die erfüllt werden müssen. Der Unterschied ist, dass wir hier nur zwei mögliche Werte pro Zelle haben (0 oder 1), dafür aber vier verschiedene Richtungen berücksichtigen müssen.

Ich habe mich für einen Backtracking-Ansatz mit Heuristiken entschieden. Das bedeutet, dass ich systematisch Werte ausprobiere und bei Widersprüchen zurückgehe. Um das Ganze effizienter zu machen, verwende ich zwei Techniken:

\begin{enumerate}
    \item \textbf{Constraint Propagation}: Wenn eine Zeile oder Diagonale schon voll ist oder noch alle verbleibenden Zellen gefüllt werden müssen, setze ich diese automatisch.
    \item \textbf{Heatmap-Heuristik}: Ich berechne für jede Zelle, wie wahrscheinlich sie gefüllt ist, und wähle die Zellen clever aus.
\end{enumerate}

% ============================================
% 2. THEORETISCHE GRUNDLAGEN
% ============================================
\section{Theoretische Grundlagen}

Bevor ich mit der eigentlichen Implementierung beginne, möchte ich einige theoretische Konzepte erklären, die für das Verständnis meiner Lösung wichtig sind.

\subsection{Constraint Satisfaction Problems}

Das Bibertomograph-Problem gehört zur Klasse der \textit{Constraint Satisfaction Problems} (CSP). Ein CSP besteht aus:

\begin{itemize}
    \item Einer Menge von \textbf{Variablen} (hier: die $n^2$ Zellen des Rasters)
    \item Einer \textbf{Domäne} für jede Variable (hier: \{0, 1\} für leer oder gefüllt)
    \item Einer Menge von \textbf{Constraints} (hier: die Summen für jede Zeile, Spalte und Diagonale)
\end{itemize}

Eine Lösung ist eine Belegung aller Variablen, sodass alle Constraints erfüllt sind.

\subsection{Backtracking}

Backtracking ist ein Algorithmus, der systematisch alle möglichen Belegungen durchprobiert. Er funktioniert rekursiv:

\begin{enumerate}
    \item Wähle eine nicht zugewiesene Variable
    \item Probiere einen Wert aus der Domäne
    \item Prüfe, ob alle Constraints noch erfüllbar sind
    \item Wenn ja: Gehe rekursiv zum nächsten Schritt
    \item Wenn nein: Probiere den nächsten Wert (Backtrack)
\end{enumerate}

Das Problem bei naivem Backtracking ist die Laufzeit. Bei einem $8 \times 8$ Raster gäbe es theoretisch $2^{64}$ mögliche Belegungen. Deshalb sind Optimierungen wichtig.

\subsection{Constraint Propagation}

Constraint Propagation ist eine Technik, um den Suchraum zu verkleinern. Die Idee ist einfach: Wenn durch die bisherigen Entscheidungen bestimmte Zellen eindeutig festgelegt sind, setze ich sie sofort.

Beispiel: Wenn in einer Zeile mit Zielsumme 3 bereits 3 Zellen gefüllt sind, müssen alle verbleibenden Zellen leer sein. Umgekehrt: Wenn die Zielsumme 3 ist und noch genau 3 Zellen unzugewiesen sind, müssen alle gefüllt werden.

\subsection{Verwendete Java-Konzepte}

Für die Implementierung habe ich folgende Java-Konstrukte verwendet:

\begin{itemize}
    \item \texttt{ArrayList<Grid>}: Eine dynamische Liste zum Speichern der gefundenen Lösungen
    \item \texttt{int[][]}: Zweidimensionale Arrays für das Raster
    \item \texttt{System.arraycopy()}: Effizientes Kopieren von Arrays für das Backtracking
    \item \texttt{BufferedReader}: Zum Einlesen der Eingabedateien
\end{itemize}

% ============================================
% 3. PROGRAMMSTRUKTUR
% ============================================
\section{Programmstruktur}

Mein Programm besteht aus fünf Klassen, die jeweils eine bestimmte Aufgabe haben. Diese Aufteilung macht den Code übersichtlicher und leichter zu testen.

\subsection{Übersicht der Klassen}

\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Klasse} & \textbf{Beschreibung} \\
\hline
\texttt{Main.java} & Einstiegspunkt des Programms. Liest die Eingabedatei, startet den Solver und gibt die Ergebnisse aus. \\
\hline
\texttt{Grid.java} & Repräsentiert das $n \times n$ Raster. Speichert den Zustand jeder Zelle und berechnet Summen für Zeilen, Spalten und Diagonalen. \\
\hline
\texttt{Constraints.java} & Speichert die Zielwerte (Randsummen) und berechnet die Heatmap für die Heuristik. \\
\hline
\texttt{InputParser.java} & Liest die Eingabedatei und erzeugt ein Constraints-Objekt. \\
\hline
\texttt{HeuristicSolver.java} & Der eigentliche Lösungsalgorithmus mit Backtracking, Constraint Propagation und Heuristik. \\
\hline
\end{tabularx}

\subsection{Main.java -- Hauptprogramm}

Die Main-Klasse ist der Einstiegspunkt und koordiniert den gesamten Ablauf:

\begin{enumerate}
    \item Liest den Dateinamen aus den Kommandozeilenargumenten
    \item Parst die Eingabedatei mit \texttt{InputParser.parse()}
    \item Berechnet die Heatmap für die Heuristik
    \item Erstellt einen \texttt{HeuristicSolver} und sammelt bis zu 100 Lösungen
    \item Gibt die Ergebnisse formatiert aus (Heatmap, Lösungen, Statistiken)
\end{enumerate}

\subsection{Grid.java -- Das Raster}

Die Grid-Klasse repräsentiert das Spielfeld als 2D-Array. Jede Zelle kann drei Zustände haben:
\begin{itemize}
    \item \texttt{-1}: Noch nicht zugewiesen
    \item \texttt{0}: Leer (wird als \texttt{.} ausgegeben)
    \item \texttt{1}: Gefüllt (wird als \texttt{\#} ausgegeben)
\end{itemize}

Die Klasse bietet Methoden zum Setzen/Abfragen von Zellen und zum Berechnen der aktuellen Summen. Besonders wichtig ist die \texttt{copy()}-Methode für das Backtracking, da wir bei Fehlversuchen zum vorherigen Zustand zurückkehren müssen.

\textbf{Diagonalen-Indexierung:} Für ein $n \times n$-Raster gibt es $2n-1$ Haupt- und Nebendiagonalen. Die Indexierung war einer der schwierigsten Teile:
\begin{itemize}
    \item Hauptdiagonale ($\searrow$): $k = \text{row} + \text{col}$, Bereich: $0$ bis $2n-2$
    \item Nebendiagonale ($\nearrow$): $k = \text{col} - \text{row} + (n-1)$
\end{itemize}

% ============================================
% 4. DER SOLVER-ALGORITHMUS
% ============================================
\section{Der Solver-Algorithmus}

Der HeuristicSolver ist das Herzstück meines Programms. Er kombiniert Backtracking mit Constraint Propagation und einer Heatmap-Heuristik.

\subsection{Die Heatmap-Heuristik}

Die Heatmap berechnet für jede Zelle einen Wert zwischen 0 und 1, der angibt, wie wahrscheinlich die Zelle gefüllt ist. Die Berechnung basiert auf der \textbf{Dichte} der vier Linien durch jede Zelle:

$$\text{Dichte einer Linie} = \frac{\text{Zielsumme}}{\text{Länge der Linie}}$$

Der Heatmap-Wert einer Zelle ist der Durchschnitt der vier Dichten (Zeile, Spalte, beide Diagonalen). Ein hoher Wert (nahe 1) bedeutet, dass die Zelle wahrscheinlich gefüllt ist; ein niedriger Wert (nahe 0) bedeutet wahrscheinlich leer. Werte nahe 0.5 sind unsicher.

\begin{lstlisting}[language=Java, caption=Kernidee der Heatmap]
// Durchschnitt der vier Liniendichten
heatmap[i][j] = (rowDensity + colDensity + 
                 diagDownDensity + diagUpDensity) / 4.0;
\end{lstlisting}

\subsection{Backtracking mit Heuristik}

Der Backtracking-Algorithmus wählt immer die Zelle aus, bei der wir am \glqq sichersten\grqq{} sind -- also Zellen, deren Heatmap-Wert weit von 0.5 entfernt ist.

\textbf{Ablauf:}
\begin{enumerate}
    \item \textbf{Zellauswahl:} Wähle die unzugewiesene Zelle mit dem extremsten Heatmap-Wert
    \item \textbf{Wertreihenfolge:} Bei Heatmap $\geq 0.5$ probiere zuerst 1, sonst zuerst 0
    \item \textbf{Forward Check:} Prüfe, ob der Wert überhaupt noch möglich ist
    \item \textbf{Setzen \& Propagieren:} Setze den Wert und führe Constraint Propagation durch
    \item \textbf{Rekursion:} Gehe zur nächsten Zelle oder speichere die Lösung
    \item \textbf{Backtrack:} Bei Konflikt probiere den anderen Wert oder gehe zurück
\end{enumerate}

\begin{lstlisting}[language=Java, caption=Backtracking-Algorithmus]
private void backtrack(Grid grid) {
    if (solutions.size() >= maxSolutions) return;
    nodeCount++;
    
    // Waehle naechste Zelle basierend auf Heuristik
    int[] nextCell = selectNextCell(grid);
    
    // Alle Zellen zugewiesen? Pruefe Loesung
    if (nextCell == null) {
        if (isValidSolution(grid)) solutions.add(grid.copy());
        return;
    }
    
    int row = nextCell[0], col = nextCell[1];
    
    // Reihenfolge basierend auf Heatmap
    int[] valuesToTry = (heatmap[row][col] >= 0.5) 
        ? new int[]{1, 0} : new int[]{0, 1};
    
    for (int value : valuesToTry) {
        if (!isValueFeasible(grid, row, col, value)) continue;
        Grid newGrid = grid.copy();
        newGrid.set(row, col, value);
        if (propagate(newGrid)) backtrack(newGrid);
    }
}
\end{lstlisting}

\subsection{Constraint Propagation}

Die Propagation prüft nach jedem gesetzten Wert alle Zeilen, Spalten und Diagonalen auf zwei wichtige Fälle:

\begin{itemize}
    \item \textbf{Konflikt erkennen:} Wenn bereits mehr Zellen gefüllt sind als die Zielsumme erlaubt, oder wenn nicht genug leere Zellen übrig sind, liegt ein Widerspruch vor $\rightarrow$ Backtrack.
    \item \textbf{Erzwungene Werte setzen:} 
    \begin{itemize}
        \item Wenn $\text{remaining} = \text{unassigned}$: Alle verbleibenden Zellen müssen 1 sein
        \item Wenn $\text{remaining} = 0$: Alle verbleibenden Zellen müssen 0 sein
    \end{itemize}
\end{itemize}

Durch das automatische Setzen erzwungener Werte können oft ganze Bereiche ohne Backtracking gelöst werden. Die Propagation wird wiederholt, bis keine neuen Werte mehr gesetzt werden.

\subsection{Forward Checking}

Forward Checking prüft \textit{vor} dem Setzen eines Wertes, ob dieser überhaupt noch möglich ist. Das spart viele unnötige Rekursionen:

\begin{itemize}
    \item \textbf{Für value = 1:} Prüfe, ob in allen vier Linien noch Platz für eine weitere gefüllte Zelle ist (aktuelle Summe $<$ Zielsumme).
    \item \textbf{Für value = 0:} Prüfe, ob nach dem Setzen auf 0 noch genügend leere Zellen übrig bleiben, um die benötigte Anzahl gefüllter Zellen zu erreichen.
\end{itemize}

Durch diese Vorprüfung werden offensichtlich ungültige Werte sofort verworfen, ohne dass erst ein Widerspruch durch Propagation gefunden werden muss.

% ============================================
% 5. EINGABE UND AUSGABE
% ============================================
\section{Eingabe und Ausgabe}

\subsection{Eingabeformat}

Die Eingabedateien haben ein einfaches Format:
\begin{enumerate}
    \item Zeile 1: Die Größe $n$ des Rasters
    \item Zeile 2: Die $n$ Spaltensummen (von links nach rechts)
    \item Zeile 3: Die $n$ Zeilensummen (von oben nach unten)
    \item Zeile 4: Die $2n-1$ Hauptdiagonalsummen
    \item Zeile 5: Die $2n-1$ Nebendiagonalsummen
\end{enumerate}

Die \texttt{InputParser}-Klasse liest diese Werte zeilenweise ein und erzeugt ein \texttt{Constraints}-Objekt.

\subsection{Ausgabeformat}

Das Programm gibt die Lösung als Raster aus, wobei \texttt{\#} für gefüllte und \texttt{.} für leere Zellen steht. Bei mehreren Lösungen wird zusätzlich eine kombinierte Ansicht gezeigt, wo \texttt{?} für mehrdeutige Zellen steht.

\subsection{Ausführung}

Um das Programm auszuführen, benötigt man Java (mindestens Version 11). Alle Befehle müssen aus dem Hauptverzeichnis des Projekts ausgeführt werden (dort wo sich die Ordner \texttt{src/} und \texttt{testdata/} befinden).

Der einfachste Aufruf erfolgt über:

\begin{verbatim}
java src/Main.java testdata/tomograph00.txt
\end{verbatim}

Alternativ kann man zuerst kompilieren und dann ausführen:

\begin{verbatim}
javac src/*.java
java -cp src Main testdata/tomograph00.txt
\end{verbatim}

Das Programm gibt dann die Heatmap, die gefundenen Lösungen und Statistiken aus.

% ============================================
% 6. BEISPIELE
% ============================================
\section{Beispiele aus dem Wettbewerb}

Hier zeige ich die Ergebnisse für drei Testdateien aus dem Wettbewerb nebeneinander:

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{tomograph01 (2×2)} & \textbf{tomograph00 (8×8)} & \textbf{tomograph03 (4×4)} \\
\textbf{Eindeutig} & \textbf{Eindeutig} & \textbf{Mehrdeutig} \\
\hline
& & \\
\texttt{..} & \texttt{..\#\#\#...} & \texttt{.??\#} \\
\texttt{\#.} & \texttt{..\#.\#...} & \texttt{?\#\#?} \\
 & \texttt{..\#\#\#...} & \texttt{?..?} \\
 & \texttt{\#..\#....} & \texttt{.??\#} \\
 & \texttt{.\#\#\#\#\#\#.} & \\
 & \texttt{...\#..\#.} & \\
 & \texttt{...\#...\#} & \\
 & \texttt{..\#.\#...} & \\
& & \\
\hline
1 Lösung, 1 Knoten & 1 Lösung, 6 Knoten & 2 Lösungen, 5 Knoten \\
\hline
\end{tabular}
\end{center}

\subsection{Erläuterung der Beispiele}

\textbf{tomograph01} ist das kleinste Beispiel (2×2). Die Constraints sind so restriktiv, dass der Solver die Lösung sofort durch Constraint Propagation findet -- ohne jegliches Backtracking.

\textbf{tomograph00} zeigt ein größeres 8×8 Raster. Trotz der Größe findet der Solver die eindeutige Lösung in nur 6 Knoten, weil die Heuristik die richtigen Zellen zuerst wählt.

\textbf{tomograph03} ist besonders interessant: Es gibt \textbf{zwei gültige Lösungen}. Die Zellen mit \texttt{?} können sowohl gefüllt als auch leer sein. Das zeigt, dass die Randsummen allein nicht immer eine eindeutige Lösung bestimmen.

Die beiden Lösungen für tomograph03 sind:
\begin{center}
\begin{tabular}{cc}
\textbf{Lösung 1} & \textbf{Lösung 2} \\
\texttt{.\#.\#} & \texttt{..\#\#} \\
\texttt{.\#\#\#} & \texttt{\#\#\#.} \\
\texttt{\#...} & \texttt{...\#} \\
\texttt{..\#\#} & \texttt{.\#.\#} \\
\end{tabular}
\end{center}

% ============================================
% 7. LAUFZEIT UND PERFORMANCE
% ============================================
\section{Laufzeit und Performance}

\subsection{Theoretische Komplexität}

Die theoretische Laufzeitkomplexität des Bibertomograph-Problems lässt sich wie folgt analysieren:

\textbf{Worst-Case (naives Backtracking):} Bei einem $n \times n$ Raster hat jede Zelle zwei mögliche Werte (0 oder 1). Ohne Optimierungen müsste man im schlimmsten Fall alle $2^{n^2}$ Kombinationen durchprobieren. Das ergibt eine Komplexität von:
$$O(2^{n^2})$$

Für ein 8×8 Raster wären das $2^{64} \approx 1.8 \cdot 10^{19}$ Möglichkeiten -- praktisch unlösbar.

\textbf{Mit Constraint Propagation:} Durch das frühzeitige Erkennen von Widersprüchen und das automatische Setzen von erzwungenen Zellen wird der Suchbaum erheblich beschnitten. Die tatsächliche Komplexität hängt stark von den Constraints ab:
\begin{itemize}
    \item Bei stark eingeschränkten Problemen (viele Nullen oder volle Zeilen) kann die Lösung oft in $O(n^2)$ gefunden werden, weil die Propagation alles löst.
    \item Bei weniger eingeschränkten Problemen liegt die praktische Komplexität typischerweise bei $O(k \cdot n^2)$, wobei $k$ die Anzahl der Backtracking-Schritte ist.
\end{itemize}

\subsection{Praktische Messungen}

In der Praxis zeigt sich, dass mein Solver sehr effizient arbeitet:

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Testfall} & \textbf{Größe} & \textbf{Knoten} & \textbf{Zeit} \\
\hline
tomograph00 & 8×8 & 6 & 36 ms \\
\hline
tomograph01 & 2×2 & 1 & 33 ms \\
\hline
tomograph02 & 4×4 & 1 & 44 ms \\
\hline
tomograph03 & 4×4 & 5 & 34 ms \\
\hline
\end{tabular}
\end{center}

Die geringe Anzahl der durchsuchten Knoten zeigt, dass die Heuristiken gut funktionieren. Die Laufzeit liegt bei allen Testfällen bei etwa 30-45 ms, wobei der Großteil davon für das Laden und die JVM-Initialisierung verwendet wird. Die eigentliche Lösung wird in unter 1 ms gefunden.

\subsection{Warum ist der Solver so schnell?}

Drei Faktoren machen den Solver effizient:

\begin{enumerate}
    \item \textbf{Frühe Erkennung von Sackgassen:} Forward Checking prüft vor jedem Setzen, ob der Wert überhaupt noch möglich ist. Dadurch werden viele unnötige Rekursionen vermieden.
    \item \textbf{Automatisches Füllen:} Wenn eine Zeile/Spalte/Diagonale nur noch eine Möglichkeit hat, wird sie sofort gesetzt. Das reduziert die Anzahl der Entscheidungspunkte.
    \item \textbf{Kluge Reihenfolge:} Die Heatmap-Heuristik wählt zuerst die Zellen, bei denen wir am sichersten sind. Dadurch werden Fehler früh erkannt.
\end{enumerate}

% ============================================
% 8. FAZIT
% ============================================
\section{Fazit und Ausblick}

\subsection{Was funktioniert gut?}

Mein Solver löst alle Testfälle des Wettbewerbs korrekt und effizient:

\begin{itemize}
    \item Die Kombination aus Constraint Propagation und Heatmap-Heuristik reduziert die Anzahl der durchsuchten Knoten erheblich.
    \item Selbst bei größeren Rastern (8×8) ist die Laufzeit sehr kurz (unter 100 ms).
    \item Das Programm erkennt korrekt, wenn es mehrere Lösungen gibt.
\end{itemize}

\subsection{Was war schwierig?}

Die größten Herausforderungen waren:

\begin{enumerate}
    \item \textbf{Diagonalen-Indexierung}: Die korrekte Berechnung der Indizes für die Diagonalen ($k = \text{row} + \text{col}$ und $k = \text{col} - \text{row} + (n-1)$) hat am meisten Zeit gekostet.
    \item \textbf{Debugging}: Bei Backtracking-Algorithmen ist es schwer zu sehen, wo genau ein Fehler liegt. Ich habe viel mit Ausgaben gearbeitet.
    \item \textbf{Kopieren von Zuständen}: Beim Backtracking muss man aufpassen, dass man das Grid richtig kopiert, sonst ändert man versehentlich den ursprünglichen Zustand.
\end{enumerate}

\subsection{Mögliche Verbesserungen}

\begin{itemize}
    \item \textbf{Arc Consistency}: Eine stärkere Form der Propagation, die noch mehr Suchraum eliminieren könnte.
    \item \textbf{Parallelisierung}: Für sehr große Raster könnte man verschiedene Teilbäume parallel durchsuchen.
    \item \textbf{GUI}: Eine grafische Oberfläche würde die Ergebnisse anschaulicher machen.
\end{itemize}

% ============================================
% 8. ARBEITSPROZESSBERICHT
% ============================================
\section{Arbeitsprozessbericht}

\begin{longtable}{|p{2.2cm}|p{3cm}|p{3.5cm}|p{2.5cm}|p{2.5cm}|}
\hline
\textbf{Datum} & \textbf{Geplant} & \textbf{Erreicht} & \textbf{Probleme} & \textbf{Lösung} \\
\hline
\endfirsthead
\hline
\textbf{Datum} & \textbf{Geplant} & \textbf{Erreicht} & \textbf{Probleme} & \textbf{Lösung} \\
\hline
\endhead
Mo 06.10.2025 & Konzepte Umsetzung, erste Experimente in Java & Lösungswege überlegt (Voxel-Projection, Brute-Force) & - & - \\
\hline
Mo 13.10.2025 & Mit Programmieren anfangen & Grid-Klasse angefangen & - & - \\
\hline
Mo 03.11.2025 & Weiter am Code arbeiten & Eingabe-Parser fertig, Constraints-Klasse erstellt & Diagonalen verwirrend & Erstmal ignoriert \\
\hline
Mo 10.11.2025 & Solver schreiben & Backtracking-Ansatz implementiert & Funktioniert nicht bei allen Testfällen & - \\
\hline
Mo 17.11.2025 & Bugs fixen & Diagonalen-Bug gefunden und gefixt, läuft jetzt & - & - \\
\hline
Mo 24.11.2025 & Dokumentation anfangen & LaTeX-Vorlage erstellt & pdflatex ging nicht & Pakete installiert \\
\hline
Mo 01.12.2025 & Arbeit fertig schreiben & Text geschrieben, Beispiele eingefügt & - & - \\
\hline
Mo 08.12.2025 & Nochmal drüberlesen & Kleinigkeiten korrigiert & - & - \\
\hline
\end{longtable}

% ============================================
% 10. QUELLENVERZEICHNIS
% ============================================
\section{Quellenverzeichnis}

\begin{enumerate}
    \item Bundeswettbewerb Informatik: Aufgabenblatt 44. Wettbewerb 2025/26, Aufgabe: Bibertomograph\\
    \url{https://bwinf.de/bundeswettbewerb/44/#c5529}\\
    (letzter Abruf: 7.12.2025)
    
    \item Oracle: Java SE Documentation -- ArrayList\\
    \url{https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html}\\
    (letzter Abruf: 6.12.2025)
    
    \item TH Köln: Backtracking-Algorithmus\\
    \url{https://www.gm.th-koeln.de/~hk/lehre/ala/ws0506/Praktikum/Projekt/C_blau/Backtracking_final.pdf}\\
    (letzter Abruf: 5.11.2025)
    
    \item GeeksforGeeks: Constraint Satisfaction Problems (CSP) in Artificial Intelligence\\
    \url{https://www.geeksforgeeks.org/artificial-intelligence/constraint-satisfaction-problems-csp-in-artificial-intelligence/}\\
    (letzter Abruf: 4.12.2025)
    
    \item YouTube: Voxeltracing für Heatmap\\
    \url{https://www.youtube.com/watch?v=m-b51C82-UE}\\
    (letzter Abruf: 2.12.2025)
    
    \item ResearchGate: Heuristic vs Brute-Force Comparison\\
    \url{https://www.researchgate.net/figure/Heuristic-brute-force-comparison-The-results-of-our-experiment-comparing-our-heuristic_tbl1_24017925}\\
    (letzter Abruf: 28.11.2025)
\end{enumerate}

\smallskip
{\small\textit{Verwendete Werkzeuge: VSCode mit Java Extension Pack, GitHub, GitHub Copilot}}\\
{\small\textit{Repository: \url{https://github.com/Stayroh/BwInf_Seminararbeit}}}

% ============================================
% EIDESSTATTLICHE ERKLÄRUNG
% ============================================
\newpage
\section*{Eidesstattliche Erklärung}
\addcontentsline{toc}{section}{Eidesstattliche Erklärung}

Ich versichere, dass die Präsentation von mir selbstständig erarbeitet wurde und ich keine anderen als die angegebenen Hilfsmittel benutzt habe. Diejenigen Teile der Präsentation, die anderen Werken im Wortlaut oder dem Sinn nach entnommen wurden, sind als solche kenntlich gemacht.

\vspace{3cm}
\noindent\rule{8cm}{0.4pt}\\
Ort, Datum, Unterschrift

\end{document}
